{
  "metadata": {
    "totalProblems": 9,
    "lastUpdated": "2025-10-25T09:30:19.352Z",
    "breakdown": {
      "Codechef": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 2,
        "Easy": 0,
        "Medium": 2,
        "Hard": 0
      },
      "Leetcode": {
        "total": 4,
        "Easy": 3,
        "Medium": 1,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 2,
        "Easy": 0,
        "Medium": 2,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "codechef-easy-remove-duplicates-from-sorted-list",
      "platform": "Codechef",
      "difficulty": "Easy",
      "problemName": "Remove Duplicates from Sorted List",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    Node* removeDuplicates(Node* head) {\r\n        if (!head) return head;\r\n        \r\n        Node* curr = head;\r\n        \r\n        while (curr != NULL && curr->next != NULL) {\r\n            if (curr->data == curr->next->data) {\r\n                // skip the duplicate node\r\n                Node* temp = curr->next;\r\n                curr->next = curr->next->next;\r\n                delete temp; // free memory\r\n            } else {\r\n                curr = curr->next; // move forward only if no duplicate\r\n            }\r\n        }\r\n        \r\n        return head;\r\n    }\r\n};",
        "readme": "linked-lists\n\nRemove Duplicates from Sorted List\n\nYou are given head of the non-empty sorted linked list where the value of the \nğ‘–\nğ‘¡\nâ„\ni\nth\n node will be \nğ´\nğ‘–\nA\ni\n\tâ€‹\n\n.\n\nYour task is to delete all duplicates such that each element appears only once and return the linked list sorted.\n\nInput:\nFirst line will contain \nğ‘‡\nT, number of test cases. Then the test cases follow.\nThe first line contains one integer \nğ‘\nN â€” the length of the linked list.\nThe second line contains \nğ‘\nN space separated integers \nğ´\n1\n,\nğ´\n2\n,\nâ€¦\nğ´\nğ‘\nA\n1\n\tâ€‹\n\n,A\n2\n\tâ€‹\n\n,â€¦A\nN\n\tâ€‹\n\n â€” the value of the linked list nodes starting from the head for the linked list.\n\nNote:\n\nFor Java language, you need to:\n\nComplete the function in the submit solution tab:\n\nNode removeDuplicates(Node head){...}\n\n\nÂ \nÂ \n\nFor C++ language, you need to:\n\nComplete the function in the submit solution tab:\n\nNode* removeDuplicates(Node* head){...}\n\n\nÂ \nÂ \n\nFor Python language, you need to:\n\nComplete the function in the submit solution tab:\n\ndef Node removeDuplicates(self, head):\n\nOutput:\n\nThe function you complete should return the required answer.\n\nConstraints\n1\nâ‰¤\nğ‘‡\nâ‰¤\n10\n1â‰¤Tâ‰¤10\n1\nâ‰¤\nğ‘\n,\nğ´\nğ‘–\nâ‰¤\n10\n5\n1â‰¤N,A\ni\n\tâ€‹\n\nâ‰¤10\n5\nSample 1:\nInput\nOutput\n3\n5\n1 1 6 8 8\n5\n1 2 3 4 5\n4\n5 5 5 5\n1 6 8 \n1 2 3 4 5 \n5 \nExplanation:\n\nTest case \n1\n1: We will remove duplicate entry of \n1\n1, \n8\n8. So the sorted linked list will be \n1\nâ†’\n6\nâ†’\n8\n1â†’6â†’8.\n\nTest case \n2\n2: There is no duplicate entry. So the sorted linked list will be \n1\nâ†’\n2\nâ†’\n3\nâ†’\n4\nâ†’\n5\n1â†’2â†’3â†’4â†’5.\n\nTest case \n3\n3: We will remove duplicate entry of \n5\n5. So the sorted linked list will be \n5\n5.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-25T09:29:44.000Z"
    },
    {
      "id": "gfg-medium-indexes-of-subarray-sum",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Indexes of Subarray Sum",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> subarraySum(vector<int> &arr, int target) {\r\n        int n = arr.size();\r\n        int start = 0;\r\n        long long sum = 0; // use long long to avoid overflow\r\n\r\n        for (int end = 0; end < n; end++) {\r\n            sum += arr[end];\r\n\r\n            // shrink the window if sum exceeds target\r\n            while (sum > target && start <= end) {\r\n                sum -= arr[start];\r\n                start++;\r\n            }\r\n\r\n            // check if sum matches\r\n            if (sum == target) {\r\n                return {start + 1, end + 1}; // 1-based indices\r\n            }\r\n        }\r\n        return {-1}; // if no subarray found\r\n    }\r\n};",
        "readme": "Algorithms,Arrays,Data_Structuresprefix-sum,Searchingsliding-window\n\nIndexes of Subarray Sum\nDifficulty: MediumAccuracy: 16.5%Submissions: 1.8MPoints: 4Average Time: 20m\n\nGiven an array arr[] containing only non-negative integers, your task is to find a continuous subarray (a contiguous sequence of elements) whose sum equals a specified value target. You need to return the 1-based indices of the leftmost and rightmost elements of this subarray. You need to find the first subarray whose sum is equal to the target.\n\nNote: If no such array is possible then, return [-1].\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 7, 5], target = 12\nOutput: [2, 4]\nExplanation: The sum of elements from 2nd to 4th position is 12.\nInput: arr[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 15\nOutput: [1, 5]\nExplanation: The sum of elements from 1st to 5th position is 15.\n\nInput: arr[] = [5, 3, 4], target = 2\nOutput: [-1]\nExplanation: There is no subarray with sum 2.\n\nConstraints:\n1 <= arr.size()<= 106\n0 <= arr[i] <= 103\n0 <=Â target <= 109\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T18:55:48.000Z"
    },
    {
      "id": "gfg-medium-kadane-s-algorithm",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Kadane's Algorithm",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\npublic:\r\n    int maxSubarraySum(vector<int> &arr) {\r\n        int maxSoFar = arr[0];   // overall max sum\r\n        int currentSum = arr[0]; // current subarray sum\r\n        \r\n        for (int i = 1; i < arr.size(); i++) {\r\n            // Either extend the current subarray or start a new one from arr[i]\r\n            currentSum = max(arr[i], currentSum + arr[i]);\r\n            \r\n            // Update global maximum\r\n            maxSoFar = max(maxSoFar, currentSum);\r\n        }\r\n        \r\n        return maxSoFar;\r\n    }\r\n};",
        "readme": "Arrays,Dynamic_Programming,Data_Structures,Algorithms\n\nKadane's Algorithm\nDifficulty: MediumAccuracy: 36.28%Submissions: 1.2MPoints: 4Average Time: 20m\n\nYou are given an integer array arr[]. You need to find the maximum sum of a subarray (containing at least one element) in the array arr[].\n\nNote : AÂ subarray is a continuous part of an array.\n\nExamples:\n\nInput: arr[] = [2, 3, -8, 7, -1, 2, 3]\nOutput: 11\nExplanation: The subarray [7, -1, 2, 3] has the largest sum 11.\n\nInput: arr[] = [-2, -4]\nOutput: -2\nExplanation: The subarray [-2] has the largest sum -2.\nInput: arr[] = [5, 4, 1, 7, 8]\nOutput: 25\nExplanation: The subarray [5, 4, 1, 7, 8] has the largest sum 25.\n\nConstraints:\n1 â‰¤ arr.size() â‰¤ 105\n-104 â‰¤ arr[i] â‰¤ 104\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-25T09:23:54.000Z"
    },
    {
      "id": "hackerrank-medium-arrays---ds",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Arrays - DS",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'reverseArray' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts INTEGER_ARRAY a as parameter.\n */\n\nvector<int> reverseArray(vector<int> a) {\n    reverse(a.begin(), a.end());  // use STL reverse\n    return a;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string arr_count_temp;\n    getline(cin, arr_count_temp);\n\n    int arr_count = stoi(ltrim(rtrim(arr_count_temp)));\n\n    string arr_temp_temp;\n    getline(cin, arr_temp_temp);\n\n    vector<string> arr_temp = split(rtrim(arr_temp_temp));\n\n    vector<int> arr(arr_count);\n\n    for (int i = 0; i < arr_count; i++) {\n        int arr_item = stoi(arr_temp[i]);\n\n        arr[i] = arr_item;\n    }\n\n    vector<int> res = reverseArray(arr);\n\n    for (size_t i = 0; i < res.size(); i++) {\n        fout << res[i];\n\n        if (i != res.size() - 1) {\n            fout << \" \";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "null\n\nAn array is a data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index,  (where ), that can be referenced as  or .\n\nYour task is to reverse an array of integers.\n\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\n\nExample\n\n\nReturn .\n\nFunction Description\n\nComplete the function  with the following parameter(s):\n\n: the array to reverse\n\nReturns\n\n: the reversed array\n\nInput Format\n\nThe first line contains an integer, , the number of integers in .\nThe second line contains  space-separated integers that make up .\n\nConstraints",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T18:56:56.000Z"
    },
    {
      "id": "hackerrank-medium-insert-a-node-at-the-head-of-a-linked-list",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Insert a node at the head of a linked list",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass SinglyLinkedListNode {\n    public:\n        int data;\n        SinglyLinkedListNode *next;\n\n        SinglyLinkedListNode(int node_data) {\n            this->data = node_data;\n            this->next = nullptr;\n        }\n};\n\nclass SinglyLinkedList {\n    public:\n        SinglyLinkedListNode *head;\n        SinglyLinkedListNode *tail;\n\n        SinglyLinkedList() {\n            this->head = nullptr;\n            this->tail = nullptr;\n        }\n\n};\n\nvoid print_singly_linked_list(SinglyLinkedListNode* node, string sep, ofstream& fout) {\n    while (node) {\n        fout << node->data;\n\n        node = node->next;\n\n        if (node) {\n            fout << sep;\n        }\n    }\n}\n\nvoid free_singly_linked_list(SinglyLinkedListNode* node) {\n    while (node) {\n        SinglyLinkedListNode* temp = node;\n        node = node->next;\n\n        free(temp);\n    }\n}\n\n// Complete the insertNodeAtHead function below.\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\nSinglyLinkedListNode* insertNodeAtHead(SinglyLinkedListNode* llist, int data) {\n    // Step 1: Create a new node\n    SinglyLinkedListNode* newNode = new SinglyLinkedListNode(data);\n    \n    // Step 2: Point the new node's next to the current head\n    newNode->next = llist;\n    \n    // Step 3: Return the new node as the new head\n    return newNode;\n}\n\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    SinglyLinkedList* llist = new SinglyLinkedList();\n\n    int llist_count;\n    cin >> llist_count;\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n    for (int i = 0; i < llist_count; i++) {\n        int llist_item;\n        cin >> llist_item;\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n    \n      \tSinglyLinkedListNode* llist_head = insertNodeAtHead(llist->head, llist_item);\n        llist->head = llist_head;\n    }\n\n    print_singly_linked_list(llist->head, \"\\n\", fout);\n    fout << \"\\n\";\n\n    free_singly_linked_list(llist->head);\n\n    fout.close();\n\n    return 0;\n}",
        "readme": "null\n\nThis challenge is part of a tutorial track by MyCodeSchool and is accompanied by a video lesson.\n\nGiven a pointer to the head of a linked list, insert a new node before the head. The  value in the new node should point to  and the  value should be replaced with a given value. Return a reference to the new head of the list. The head pointer given may be null meaning that the initial list is empty.\n\nFunction Description\n\nComplete the function  with the following parameter(s):\n\n: a reference to the head of a list\n: the value to insert in the  field of the new node\n\nInput Format\n\nThe first line contains an integer , the number of elements to be inserted at the head of the list.\nThe next  lines contain an integer each, the elements to be inserted, one per function call.\n\nConstraints\n\nSample Input\n\nSTDIN   Function\n-----   --------\n5       n = 5\n383     data items to insert 383 ... 321\n484\n392\n975\n321\n\n\nSample Output\n\n321\n975\n392\n484\n383\n\n\nExplanation\n\nIntially the list in NULL. After inserting 383, the list is 383 -> NULL.\nAfter inserting 484, the list is 484 -> 383 -> NULL.\nAfter inserting 392, the list is 392 -> 484 -> 383 -> NULL.\nAfter inserting 975, the list is 975 -> 392 -> 484 -> 383 -> NULL.\nAfter inserting 321, the list is 321 -> 975 -> 392 -> 484 -> 383 -> NULL.",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-25T09:25:34.000Z"
    },
    {
      "id": "leetcode-easy-palindrome-number",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Palindrome Number",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        // Condition 1: If x is negative, it can't be a palindrome (e.g., -121).\n        // Condition 2: If the number ends in 0 (x % 10 == 0) and is not 0 itself, \n        // it can't be a palindrome (e.g., 10, 200). \n        // Only 0 is a palindrome that ends in 0.\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int reversedNumber = 0;\n        \n        // Loop to build the reversed number.\n        // We stop when reversedNumber becomes greater than or equal to x.\n        // This means we've processed half of the digits.\n        while (x > reversedNumber) {\n            int digit = x % 10;\n            reversedNumber = reversedNumber * 10 + digit;\n            x /= 10;\n        }\n\n        // A palindrome check requires comparing the original number's first half (x)\n        // with the reversed number's first half (reversedNumber).\n        \n        // Case 1: The number has an even number of digits (e.g., 1221).\n        // The loop will stop when x == reversedNumber (12 == 12).\n        // We return x == reversedNumber.\n        \n        // Case 2: The number has an odd number of digits (e.g., 121).\n        // The loop will stop when x < reversedNumber (1 < 12). \n        // The middle digit is now the last digit of reversedNumber (2).\n        // To ignore the middle digit, we divide reversedNumber by 10 (12 / 10 = 1).\n        // We return x == reversedNumber / 10.\n        \n        return x == reversedNumber || x == reversedNumber / 10;\n    }\n}",
        "readme": "Math\n\nGoogleFacebookAmazonBloombergAdobeGiven an integer x, return true if x is a palindrome, and false otherwise.\n\nÂ \nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\nÂ \nConstraints:\n\n\n\t-231Â <= x <= 231Â - 1\n\n\nÂ \nFollow up: Could you solve it without converting the integer to a string?",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T19:11:49.000Z"
    },
    {
      "id": "leetcode-easy-remove-element",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Remove Element",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        // 'k' will be the count of elements not equal to 'val' \n        // and also the index where the next non-'val' element should be placed.\n        int k = 0; \n        \n        // Iterate through the array with pointer 'i'\n        for (int i = 0; i < nums.length; i++) {\n            // Check if the current element is NOT the value to remove\n            if (nums[i] != val) {\n                // If it's a desired element, place it at the 'k' position\n                nums[k] = nums[i];\n                // Increment 'k' to point to the next available spot\n                k++;\n            }\n            // If nums[i] == val, we simply skip it. The element at nums[i] is effectively\n            // \"removed\" from the first 'k' portion of the array.\n        }\n        \n        // 'k' is the number of elements in nums which are not equal to val\n        return k;\n    }\n}",
        "readme": "ArrayTwoPointers\n\nAmazonAppleAdobeGoogleMicrosoftGiven an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\n\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\n\n\tChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\n\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\nIf all assertions pass, then your solution will be accepted.\n\nÂ \nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nÂ \nConstraints:\n\n\n\t0 <= nums.length <= 100\n\t0 <= nums[i] <= 50\n\t0 <= val <= 100",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T19:14:54.000Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n         Map<Integer, Integer> mp = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            mp.put(nums[i], i );\n        }\n        //mycode\n        int[] res = new int[2];\n\n        for (int i = 0; i < nums.length; i++) {\n            \n            int later = target - nums[i];\n            if (mp.containsKey(later) && mp.get(later) != i) {\n                res = new int[]{i, mp.get(later)};\n                break;\n            }\n        }\n\n        return res;\n    }\n}",
        "readme": "ArrayHashTable\n\nGiven an array of integers numsÂ and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nÂ \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\nÂ \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\nÂ \nFollow-up:Â Can you come up with an algorithm that is less than O(n2)Â time complexity?",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-25T09:17:23.000Z"
    },
    {
      "id": "leetcode-medium-find-first-and-last-position-of-element-in-sorted-array",
      "platform": "Leetcode",
      "difficulty": "Medium",
      "problemName": "Find First and Last Position of Element in Sorted Array",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] ans = { -1, -1 };\n        int start = search(nums, target, true);\n        int end = search(nums, target, false);\n        ans[0] = start;\n        ans[1] = end;\n        return ans;\n    }\n\n    static int search(int[] num, int target, boolean firstindex) {\n        int ans = -1;\n        int start = 0;\n        int end = num.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (num[mid] > target) {\n                end = mid - 1;\n            } else if (num[mid] < target) {\n                start = mid + 1;\n            } else {\n                ans = mid;\n                if (firstindex) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "readme": "ArrayBinarySearch\n\nGiven an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou mustÂ write an algorithm withÂ O(log n) runtime complexity.\n\nÂ \nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\nÂ \nConstraints:\n\n\n\t0 <= nums.length <= 105\n\t-109Â <= nums[i]Â <= 109\n\tnums is a non-decreasing array.\n\t-109Â <= targetÂ <= 109",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T20:03:52.000Z"
    }
  ]
}