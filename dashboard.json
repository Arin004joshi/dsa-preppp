{
  "metadata": {
    "totalProblems": 3,
    "lastUpdated": "2025-10-07T19:00:11.287Z",
    "breakdown": {
      "Codechef": {
        "total": 0,
        "Easy": 0,
        "Medium": 0,
        "Hard": 0
      },
      "Gfg": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      },
      "Leetcode": {
        "total": 1,
        "Easy": 1,
        "Medium": 0,
        "Hard": 0
      },
      "Hackerrank": {
        "total": 1,
        "Easy": 0,
        "Medium": 1,
        "Hard": 0
      }
    }
  },
  "problems": [
    {
      "id": "gfg-medium-indexes-of-subarray-sum",
      "platform": "Gfg",
      "difficulty": "Medium",
      "problemName": "Indexes of Subarray Sum",
      "language": "cpp",
      "files": {
        "code": "class Solution {\r\n  public:\r\n    vector<int> subarraySum(vector<int> &arr, int target) {\r\n        int n = arr.size();\r\n        int start = 0;\r\n        long long sum = 0; // use long long to avoid overflow\r\n\r\n        for (int end = 0; end < n; end++) {\r\n            sum += arr[end];\r\n\r\n            // shrink the window if sum exceeds target\r\n            while (sum > target && start <= end) {\r\n                sum -= arr[start];\r\n                start++;\r\n            }\r\n\r\n            // check if sum matches\r\n            if (sum == target) {\r\n                return {start + 1, end + 1}; // 1-based indices\r\n            }\r\n        }\r\n        return {-1}; // if no subarray found\r\n    }\r\n};",
        "readme": "Algorithms,Arrays,Data_Structuresprefix-sum,Searchingsliding-window\n\nIndexes of Subarray Sum\nDifficulty: MediumAccuracy: 16.5%Submissions: 1.8MPoints: 4Average Time: 20m\n\nGiven an array arr[] containing only non-negative integers, your task is to find a continuous subarray (a contiguous sequence of elements) whose sum equals a specified value target. You need to return the 1-based indices of the leftmost and rightmost elements of this subarray. You need to find the first subarray whose sum is equal to the target.\n\nNote: If no such array is possible then, return [-1].\n\nExamples:\n\nInput: arr[] = [1, 2, 3, 7, 5], target = 12\nOutput: [2, 4]\nExplanation: The sum of elements from 2nd to 4th position is 12.\nInput: arr[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 15\nOutput: [1, 5]\nExplanation: The sum of elements from 1st to 5th position is 15.\n\nInput: arr[] = [5, 3, 4], target = 2\nOutput: [-1]\nExplanation: There is no subarray with sum 2.\n\nConstraints:\n1 <= arr.size()<= 106\n0 <= arr[i] <= 103\n0 <= target <= 109\n\nTry more examples\nExpected Complexities\nCompany Tags\nTopic Tags\nRelated Interview Experiences\nRelated Articles",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T18:55:48.000Z"
    },
    {
      "id": "hackerrank-medium-arrays---ds",
      "platform": "Hackerrank",
      "difficulty": "Medium",
      "problemName": "Arrays - DS",
      "language": "cpp",
      "files": {
        "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring ltrim(const string &);\nstring rtrim(const string &);\nvector<string> split(const string &);\n\n/*\n * Complete the 'reverseArray' function below.\n *\n * The function is expected to return an INTEGER_ARRAY.\n * The function accepts INTEGER_ARRAY a as parameter.\n */\n\nvector<int> reverseArray(vector<int> a) {\n    reverse(a.begin(), a.end());  // use STL reverse\n    return a;\n}\n\nint main()\n{\n    ofstream fout(getenv(\"OUTPUT_PATH\"));\n\n    string arr_count_temp;\n    getline(cin, arr_count_temp);\n\n    int arr_count = stoi(ltrim(rtrim(arr_count_temp)));\n\n    string arr_temp_temp;\n    getline(cin, arr_temp_temp);\n\n    vector<string> arr_temp = split(rtrim(arr_temp_temp));\n\n    vector<int> arr(arr_count);\n\n    for (int i = 0; i < arr_count; i++) {\n        int arr_item = stoi(arr_temp[i]);\n\n        arr[i] = arr_item;\n    }\n\n    vector<int> res = reverseArray(arr);\n\n    for (size_t i = 0; i < res.size(); i++) {\n        fout << res[i];\n\n        if (i != res.size() - 1) {\n            fout << \" \";\n        }\n    }\n\n    fout << \"\\n\";\n\n    fout.close();\n\n    return 0;\n}\n\nstring ltrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        s.begin(),\n        find_if(s.begin(), s.end(), not1(ptr_fun<int, int>(isspace)))\n    );\n\n    return s;\n}\n\nstring rtrim(const string &str) {\n    string s(str);\n\n    s.erase(\n        find_if(s.rbegin(), s.rend(), not1(ptr_fun<int, int>(isspace))).base(),\n        s.end()\n    );\n\n    return s;\n}\n\nvector<string> split(const string &str) {\n    vector<string> tokens;\n\n    string::size_type start = 0;\n    string::size_type end = 0;\n\n    while ((end = str.find(\" \", start)) != string::npos) {\n        tokens.push_back(str.substr(start, end - start));\n\n        start = end + 1;\n    }\n\n    tokens.push_back(str.substr(start));\n\n    return tokens;\n}",
        "readme": "null\n\nAn array is a data structure that stores elements of the same type in a contiguous block of memory. In an array, , of size , each memory location has some unique index,  (where ), that can be referenced as  or .\n\nYour task is to reverse an array of integers.\n\nNote: If you've already solved our C++ domain's Arrays Introduction challenge, you may want to skip this.\n\nExample\n\n\nReturn .\n\nFunction Description\n\nComplete the function  with the following parameter(s):\n\n: the array to reverse\n\nReturns\n\n: the reversed array\n\nInput Format\n\nThe first line contains an integer, , the number of integers in .\nThe second line contains  space-separated integers that make up .\n\nConstraints",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T18:56:56.000Z"
    },
    {
      "id": "leetcode-easy-two-sum",
      "platform": "Leetcode",
      "difficulty": "Easy",
      "problemName": "Two Sum",
      "language": "java",
      "files": {
        "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n         Map<Integer, Integer> mp = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            mp.put(nums[i], i );\n        }\n        //mycode\n        int[] res = new int[2];\n\n        for (int i = 0; i < nums.length; i++) {\n            \n            int later = target - nums[i];\n            if (mp.containsKey(later) && mp.get(later) != i) {\n                res = new int[]{i, mp.get(later)};\n                break;\n            }\n        }\n\n        return res;\n    }\n}",
        "readme": "ArrayHashTable\n\nAmazonAdobeGoogleAppleMicrosoftGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
        "notes": ""
      },
      "hasCode": true,
      "hasReadme": true,
      "hasNotes": false,
      "lastUpdated": "2025-10-07T18:59:56.000Z"
    }
  ]
}